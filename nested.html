<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Structure Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f7f9fc;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .file-input {
            margin: 20px 0;
        }

        input[type="file"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f5f5f5;
        }

        .tree-container {
            margin-top: 20px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow: auto;
            max-height: 80vh;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
        }

        .tree-node {
            padding: 2px 0;
            white-space: nowrap;
        }

        .tree-content {
            margin-left: 5px;
            display: inline-block;
        }

        .toggle {
            cursor: pointer;
            display: inline-block;
            width: 16px;
            text-align: center;
            color: #2980b9;
            font-weight: bold;
        }

        .children {
            padding-left: 20px;
        }

        .collapsed {
            display: none;
        }

        .level-info {
            color: #7f8c8d;
            font-size: 12px;
            margin-left: 4px;
        }

        .search-bar {
            margin: 20px 0;
        }

        #searchInput {
            padding: 10px;
            width: 300px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }

        button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .highlight {
            background-color: #ffffc0;
        }

        .controls {
            margin: 15px 0;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 16px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hierarchical Structure Viewer</h1>

        <div class="file-input">
            <input type="file" id="fileInput" accept=".txt">
            <p><small>Select a hierarchical text file with indentation (such as an org chart)</small></p>
        </div>

        <div class="controls">
            <button id="expandAll">Expand All</button>
            <button id="collapseAll">Collapse All</button>
        </div>

        <div class="search-bar">
            <input type="text" id="searchInput" placeholder="Search for text...">
            <button id="searchBtn">Search</button>
            <button id="clearSearch">Clear</button>
        </div>

        <div id="loadingMessage" class="loading" style="display: none;">
            Processing file, please wait...
        </div>

        <div id="treeContainer" class="tree-container"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('fileInput');
            const treeContainer = document.getElementById('treeContainer');
            const expandAllBtn = document.getElementById('expandAll');
            const collapseAllBtn = document.getElementById('collapseAll');
            const searchInput = document.getElementById('searchInput');
            const searchBtn = document.getElementById('searchBtn');
            const clearSearchBtn = document.getElementById('clearSearch');
            const loadingMessage = document.getElementById('loadingMessage');

            let currentHighlights = [];

            fileInput.addEventListener('change', handleFileSelect);
            expandAllBtn.addEventListener('click', expandAll);
            collapseAllBtn.addEventListener('click', collapseAll);
            searchBtn.addEventListener('click', performSearch);
            clearSearchBtn.addEventListener('click', clearSearch);
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });

            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                loadingMessage.style.display = 'block';
                treeContainer.innerHTML = '';

                const reader = new FileReader();

                reader.onload = function(e) {
                    const content = e.target.result;
                    processFileContent(content);
                    loadingMessage.style.display = 'none';
                };

                reader.readAsText(file);
            }

            function processFileContent(content) {
                const lines = content.split('\n');
                const rootNode = { children: [], level: -1 };
                let currentNode = rootNode;
                let previousLevel = -1;

                // Build the tree structure
                lines.forEach(line => {
                    if (!line.trim()) return; // Skip empty lines

                    // Calculate indent level
                    const leadingSpaces = line.match(/^\s*/)[0].length;
                    const level = Math.floor(leadingSpaces / 4); // Assuming 4-space indentation
                    const text = line.trim();

                    // Create new node
                    const node = {
                        text: text,
                        children: [],
                        level: level
                    };

                    // Find parent node based on indentation level
                    if (level > previousLevel) {
                        // This is a child of the previous node
                        currentNode.children.push(node);
                    } else if (level === previousLevel) {
                        // This is a sibling of the previous node
                        findParentAtLevel(rootNode, level - 1).children.push(node);
                    } else {
                        // Going back up in the hierarchy
                        findParentAtLevel(rootNode, level - 1).children.push(node);
                    }

                    currentNode = node;
                    previousLevel = level;
                });

                // Render the tree with progressive loading
                renderTreeProgressive(rootNode);
            }

            function findParentAtLevel(node, targetLevel) {
                if (node.level === targetLevel) {
                    return node;
                }

                // Depth-first search through children
                for (let i = node.children.length - 1; i >= 0; i--) {
                    const child = node.children[i];
                    if (child.level <= targetLevel) {
                        return findParentAtLevel(child, targetLevel);
                    }
                }

                // Fallback to the original node if no matching level found
                return node;
            }

            function renderTreeProgressive(rootNode) {
                treeContainer.innerHTML = '';

                // Render first level nodes immediately
                rootNode.children.forEach(child => {
                    const treeNodeElement = createTreeNodeElement(child, true);
                    treeContainer.appendChild(treeNodeElement);
                });

                // Add click handlers after rendering
                addToggleHandlers();
            }

            function createTreeNodeElement(node, collapsed = true) {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'tree-node';

                // Create toggle button if node has children
                const toggleSpan = document.createElement('span');
                toggleSpan.className = 'toggle';
                toggleSpan.textContent = node.children.length ? '+' : ' ';
                toggleSpan.dataset.expanded = 'false';
                toggleSpan.dataset.loaded = node.children.length ? 'false' : 'true';
                nodeDiv.appendChild(toggleSpan);

                // Create the node content
                const contentSpan = document.createElement('span');
                contentSpan.className = 'tree-content';
                contentSpan.textContent = node.text;
                nodeDiv.appendChild(contentSpan);

                // Count indicator (if applicable)
                if (node.children.length) {
                    const countSpan = document.createElement('span');
                    countSpan.className = 'level-info';
                    countSpan.textContent = `(${node.children.length})`;
                    nodeDiv.appendChild(countSpan);
                }

                // Create container for child nodes
                if (node.children.length) {
                    const childrenDiv = document.createElement('div');
                    childrenDiv.className = 'children';
                    if (collapsed) {
                        childrenDiv.classList.add('collapsed');
                    }

                    // Store children data as attribute for lazy loading
                    nodeDiv.dataset.children = JSON.stringify(node.children);

                    nodeDiv.appendChild(childrenDiv);
                }

                return nodeDiv;
            }

            function addToggleHandlers() {
                const toggles = document.querySelectorAll('.toggle');
                toggles.forEach(toggle => {
                    if (toggle.textContent === '+' || toggle.textContent === '−') {
                        toggle.addEventListener('click', function() {
                            const nodeDiv = this.parentNode;
                            const childrenDiv = nodeDiv.querySelector('.children');
                            const isExpanded = this.dataset.expanded === 'true';
                            const isLoaded = this.dataset.loaded === 'true';

                            if (isExpanded) {
                                // Collapse
                                this.textContent = '+';
                                this.dataset.expanded = 'false';
                                childrenDiv.classList.add('collapsed');
                            } else {
                                // Expand
                                this.textContent = '−';
                                this.dataset.expanded = 'true';
                                childrenDiv.classList.remove('collapsed');

                                // Lazy load children if not loaded yet
                                if (!isLoaded) {
                                    const childrenData = JSON.parse(nodeDiv.dataset.children);
                                    loadChildren(childrenDiv, childrenData);
                                    this.dataset.loaded = 'true';

                                    // Remove the data attribute to free memory
                                    delete nodeDiv.dataset.children;
                                }
                            }
                        });
                    }
                });
            }

            function loadChildren(childrenDiv, children) {
                // Clear any placeholder or loading indicator
                childrenDiv.innerHTML = '';

                // Load children in smaller batches to prevent UI freezing
                const batchSize = 50;
                let currentIndex = 0;

                function loadBatch() {
                    const fragment = document.createDocumentFragment();
                    const endIndex = Math.min(currentIndex + batchSize, children.length);

                    for (let i = currentIndex; i < endIndex; i++) {
                        const childElement = createTreeNodeElement(children[i], true);
                        fragment.appendChild(childElement);
                    }

                    childrenDiv.appendChild(fragment);
                    currentIndex = endIndex;

                    // Add toggle handlers to the newly added nodes
                    addToggleHandlers();

                    // Continue loading if there are more children
                    if (currentIndex < children.length) {
                        setTimeout(loadBatch, 0);
                    }
                }

                loadBatch();
            }

            function expandAll() {
                // For performance reasons, only expand nodes that are already loaded
                const toggles = document.querySelectorAll('.toggle[data-loaded="true"]');
                toggles.forEach(toggle => {
                    if (toggle.textContent === '+') {
                        toggle.click();
                    }
                });
            }

            function collapseAll() {
                const toggles = document.querySelectorAll('.toggle');
                toggles.forEach(toggle => {
                    if (toggle.textContent === '−') {
                        toggle.click();
                    }
                });
            }

            function performSearch() {
                clearSearch();

                const searchTerm = searchInput.value.trim().toLowerCase();
                if (!searchTerm) return;

                const contentElements = document.querySelectorAll('.tree-content');
                let foundAny = false;

                contentElements.forEach(element => {
                    const text = element.textContent.toLowerCase();
                    if (text.includes(searchTerm)) {
                        element.classList.add('highlight');
                        currentHighlights.push(element);
                        foundAny = true;

                        // Expand all parent nodes to show the match
                        let parent = element.parentNode;
                        while (parent && !parent.classList.contains('tree-container')) {
                            if (parent.classList.contains('children') && parent.classList.contains('collapsed')) {
                                const toggleBtn = parent.parentNode.querySelector('.toggle');
                                if (toggleBtn) toggleBtn.click();
                            }
                            parent = parent.parentNode;
                        }
                    }
                });

                if (foundAny) {
                    // Scroll to the first match
                    if (currentHighlights.length > 0) {
                        currentHighlights[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    alert('No matches found for: ' + searchTerm);
                }
            }

            function clearSearch() {
                currentHighlights.forEach(element => {
                    element.classList.remove('highlight');
                });
                currentHighlights = [];
                searchInput.value = '';
            }
        });
    </script>
</body>
</html>